# ğŸš€ é«˜çº§æ€§èƒ½ä¼˜åŒ–æŠ€å·§å¤§å…¨

> åŸºäºUSearchæºç çš„æ·±åº¦æ€§èƒ½ä¼˜åŒ–å®æˆ˜æŒ‡å—
>
> æ¶µç›–ç¼–è¯‘å™¨ä¼˜åŒ–ã€ä½è¿ç®—ã€å†…å­˜ç®¡ç†ã€å¾ªç¯ä¼˜åŒ–ã€æ•°æ®ç»“æ„ç­‰å„ä¸ªæ–¹é¢

---

## ç›®å½•

1. [ç¼–è¯‘å™¨ä¼˜åŒ–æŒ‡ä»¤](#1-ç¼–è¯‘å™¨ä¼˜åŒ–æŒ‡ä»¤)
2. [ä½è¿ç®—é»‘ç§‘æŠ€](#2-ä½è¿ç®—é»‘ç§‘æŠ€)
3. [å¾ªç¯ä¼˜åŒ–ä¸å‘é‡åŒ–](#3-å¾ªç¯ä¼˜åŒ–ä¸å‘é‡åŒ–)
4. [å†…å­˜ç®¡ç†ç­–ç•¥](#4-å†…å­˜ç®¡ç†ç­–ç•¥)
5. [åˆ†æ”¯æ¶ˆé™¤æŠ€å·§](#5-åˆ†æ”¯æ¶ˆé™¤æŠ€å·§)
6. [æ•°æ®ç»“æ„ç´§å‡‘æ€§](#6-æ•°æ®ç»“æ„ç´§å‡‘æ€§)
7. [ç±»å‹ç³»ç»Ÿä¼˜åŒ–](#7-ç±»å‹ç³»ç»Ÿä¼˜åŒ–)
8. [ç¼–è¯‘æœŸè®¡ç®—](#8-ç¼–è¯‘æœŸè®¡ç®—)
9. [å¹³å°ç‰¹å®šä¼˜åŒ–](#9-å¹³å°ç‰¹å®šä¼˜åŒ–)
10. [å¾®æ¶æ„çº§ä¼˜åŒ–](#10-å¾®æ¶æ„çº§ä¼˜åŒ–)
11. [æ€§èƒ½æµ‹é‡æ–¹æ³•](#11-æ€§èƒ½æµ‹é‡æ–¹æ³•)
12. [åæ¨¡å¼è­¦ç¤º](#12-åæ¨¡å¼è­¦ç¤º)

---

## 1. ç¼–è¯‘å™¨ä¼˜åŒ–æŒ‡ä»¤

### 1.1 å‡½æ•°å†…è”æ§åˆ¶

**always_inline vs inline**

```cpp
// âŒ ä»…å»ºè®®ç¼–è¯‘å™¨å†…è”
inline int add(int a, int b) {
    return a + b;
}

// âœ… å¼ºåˆ¶å†…è” (GCC/Clang)
__attribute__((always_inline)) inline int add_forced(int a, int b) {
    return a + b;
}

// âœ… ç¦æ­¢å†…è” (ç”¨äºprofiling)
__attribute__((noinline)) int complex_function() {
    // æ€§èƒ½åˆ†ææ—¶ä¿ç•™å‡½æ•°è°ƒç”¨æ ˆ
}
```

**USearchä¸­çš„åº”ç”¨ (index.hpp:123):**

```cpp
#define usearch_profiled_m __attribute__((noinline))
#define usearch_profile_name_m(name) \
    __asm__ volatile(".globl " usearch_stringify_m(usearch_concat_m(name, __COUNTER__)) "\n" \
                     usearch_stringify_m(usearch_concat_m(name, __COUNTER__)) ":")

// ä½¿ç”¨ç¤ºä¾‹
usearch_profiled_m bool reserve(std::size_t new_capacity) noexcept {
    usearch_profile_name_m(max_heap_reserve);
    // ... å®ç°
}
```

ğŸ’¡ **ä¸ºä»€ä¹ˆnoinlineå¯¹æ€§èƒ½æœ‰åˆ©?**
- Profilingå·¥å…·å¯ä»¥ç²¾ç¡®å®šä½çƒ­ç‚¹
- å‡å°‘æŒ‡ä»¤ç¼“å­˜å‹åŠ› (I-cache)
- é¿å…è¿‡åº¦å†…è”å¯¼è‡´çš„ä»£ç è†¨èƒ€

**æ€§èƒ½å¯¹æ¯”:**

| åœºæ™¯ | always_inline | noinline | ç¼–è¯‘å™¨å†³å®š |
|------|--------------|----------|-----------|
| å°å‡½æ•°(<5è¡Œ) | âœ… æ›´å¿« | âŒ æ…¢ | âœ… é€šå¸¸OK |
| å¤§å‡½æ•°(>50è¡Œ) | âŒ ä»£ç è†¨èƒ€ | âœ… æ›´å¥½ | âœ… é€šå¸¸OK |
| çƒ­ç‚¹å‡½æ•° | âœ… æ›´å¿« | âŒ æ…¢ | âš ï¸ å¯èƒ½ä¸å†…è” |
| Profiling | âŒ éš¾åˆ†æ | âœ… æ¸…æ™° | âš ï¸ ç¬¦å·å¯èƒ½è¢«ä¼˜åŒ–æ‰ |

### 1.2 å¾ªç¯å‘é‡åŒ–æç¤º

**ç¼–è¯‘å™¨ç‰¹å®šçš„å‘é‡åŒ–æŒ‡ä»¤:**

```cpp
// index_plugins.hpp:1404-1411
inline result_t hamming_distance(
    scalar_t const* a,
    scalar_t const* b,
    std::size_t words
) const noexcept {
    result_t matches{};

#if USEARCH_USE_OPENMP
    // OpenMP SIMDæŒ‡ä»¤
    #pragma omp simd reduction(+ : matches)
#elif defined(USEARCH_DEFINED_CLANG)
    // Clangå‘é‡åŒ–æç¤º
    #pragma clang loop vectorize(enable)
#elif defined(USEARCH_DEFINED_GCC)
    // GCCä¾èµ–æ€§æç¤º (å‘Šè¯‰ç¼–è¯‘å™¨æ²¡æœ‰å¾ªç¯ä¾èµ–)
    #pragma GCC ivdep
#endif

    for (std::size_t i = 0; i != words; ++i) {
        matches += std::bitset<bits_per_word_k>(a[i] ^ b[i]).count();
    }

    return matches;
}
```

**å„ç¼–è¯‘å™¨æŒ‡ä»¤å¯¹æ¯”:**

| æŒ‡ä»¤ | ç¼–è¯‘å™¨ | ä½œç”¨ | ä¿è¯æ€§ |
|------|--------|------|--------|
| `#pragma omp simd` | GCC/Clang/ICC | å¼ºåˆ¶SIMDå‘é‡åŒ– | å¼º |
| `#pragma clang loop vectorize(enable)` | Clang | å¯ç”¨å‘é‡åŒ– | ä¸­ |
| `#pragma GCC ivdep` | GCC | å¿½ç•¥å¾ªç¯ä¾èµ– | å¼± |
| `#pragma loop(ivdep)` | MSVC | å¿½ç•¥å¾ªç¯ä¾èµ– | å¼± |

**éªŒè¯å‘é‡åŒ–æˆåŠŸ:**

```bash
# GCC - æŸ¥çœ‹å‘é‡åŒ–æŠ¥å‘Š
g++ -O3 -fopt-info-vec-optimized -fopt-info-vec-missed code.cpp

# Clang - æŸ¥çœ‹ä¼˜åŒ–å¤‡æ³¨
clang++ -O3 -Rpass=loop-vectorize -Rpass-missed=loop-vectorize code.cpp

# æŸ¥çœ‹ç”Ÿæˆçš„æ±‡ç¼–
objdump -d -M intel program | less
# æŸ¥æ‰¾: vmovups, vaddps, vfmadd (AVX)
#      vpaddd, vpmulld (AVX2æ•´æ•°)
```

### 1.3 noexceptä¼˜åŒ–

**ä¸ºä»€ä¹ˆnoexcepté‡è¦:**

```cpp
// âŒ å¯èƒ½æŠ›å¼‚å¸¸ - ç¼–è¯‘å™¨ç”Ÿæˆé¢å¤–ä»£ç 
void process_data(std::vector<int>& data) {
    for (auto& x : data) {
        x *= 2;
    }
}

// âœ… æ‰¿è¯ºä¸æŠ›å¼‚å¸¸ - ç¼–è¯‘å™¨ä¼˜åŒ–æ›´æ¿€è¿›
void process_data_fast(std::vector<int>& data) noexcept {
    for (auto& x : data) {
        x *= 2;
    }
}
```

**ç”Ÿæˆçš„ä»£ç å·®å¼‚ (ç®€åŒ–):**

```asm
; ä¸å¸¦noexcept
process_data:
    push rbx
    mov rbx, rdi
    call check_exception_handlers  ; é¢å¤–å¼€é”€!
    ; ... å®é™…é€»è¾‘
    call cleanup_exceptions         ; é¢å¤–å¼€é”€!
    pop rbx
    ret

; å¸¦noexcept
process_data_fast:
    ; ... å®é™…é€»è¾‘ (ç›´æ¥æ‰§è¡Œ)
    ret
```

**æ€§èƒ½æå‡:** 5-15% (å–å†³äºå‡½æ•°å¤æ‚åº¦)

**USearchçš„ç­–ç•¥ (index.hpp:149):**

```cpp
#if defined(NDEBUG)
    #define usearch_noexcept_m noexcept
#else
    #define usearch_noexcept_m  // Debugæ—¶å…è®¸å¼‚å¸¸
#endif

// ä½¿ç”¨
void critical_path() usearch_noexcept_m {
    // é«˜æ€§èƒ½å…³é”®è·¯å¾„
}
```

### 1.4 restrictå…³é”®å­—

**å‘Šè¯‰ç¼–è¯‘å™¨æŒ‡é’ˆä¸é‡å :**

```cpp
// âŒ ç¼–è¯‘å™¨å¿…é¡»å‡è®¾aå’Œbå¯èƒ½é‡å 
void add_arrays(float* a, float* b, float* c, size_t n) {
    for (size_t i = 0; i < n; i++) {
        c[i] = a[i] + b[i];
    }
}

// âœ… ç¼–è¯‘å™¨å¯ä»¥å®‰å…¨åœ°å‘é‡åŒ–
void add_arrays_restrict(
    float* __restrict__ a,
    float* __restrict__ b,
    float* __restrict__ c,
    size_t n
) {
    for (size_t i = 0; i < n; i++) {
        c[i] = a[i] + b[i];  // å¯ä»¥å®‰å…¨SIMDåŒ–
    }
}
```

**æ€§èƒ½å·®å¼‚ç¤ºä¾‹ (1000ä¸‡å…ƒç´ ):**

| ç‰ˆæœ¬ | æ—¶é—´ | ååé‡ |
|------|------|--------|
| æ— restrict | 45ms | 667 MElements/s |
| æœ‰restrict | 12ms | 2500 MElements/s |
| **æå‡** | **3.75x** | |

---

## 2. ä½è¿ç®—é»‘ç§‘æŠ€

### 2.1 å¿«é€Ÿ2çš„å¹‚æ¬¡å‘ä¸Šå–æ•´

**index.hpp:185-196**

```cpp
// å°†ä»»æ„æ•°å‘ä¸Šå–æ•´åˆ°2çš„å¹‚
inline std::size_t ceil2(std::size_t v) noexcept {
    v--;
    v |= v >> 1;
    v |= v >> 2;
    v |= v >> 4;
    v |= v >> 8;
    v |= v >> 16;
#ifdef USEARCH_64BIT_ENV
    v |= v >> 32;
#endif
    v++;
    return v;
}
```

**å·¥ä½œåŸç†å¯è§†åŒ–:**

```
è¾“å…¥: v = 100 (äºŒè¿›åˆ¶: 0000000001100100)

v--;          0000000001100011
v |= v >> 1;  0000000001110011
v |= v >> 2;  0000000001111111
v |= v >> 4;  0000000001111111
v |= v >> 8;  0000000001111111
v |= v >> 16; 0000000001111111
v++;          0000000010000000 = 128 âœ“

è¾“å…¥: 1 â†’ è¾“å‡º: 1
è¾“å…¥: 2 â†’ è¾“å‡º: 2
è¾“å…¥: 3 â†’ è¾“å‡º: 4
è¾“å…¥: 100 â†’ è¾“å‡º: 128
è¾“å…¥: 1000 â†’ è¾“å‡º: 1024
```

**æ€§èƒ½å¯¹æ¯”:**

```cpp
// âŒ æ…¢ (O(log n)æ¬¡å¾ªç¯)
size_t ceil2_loop(size_t v) {
    size_t power = 1;
    while (power < v) power *= 2;
    return power;
}
// æ—¶é—´: ~15 cycles

// âœ… å¿« (å›ºå®šæŒ‡ä»¤æ•°)
size_t ceil2_bitwise(size_t v) {
    // ... ä¸Šé¢çš„å®ç°
}
// æ—¶é—´: ~6 cycles (2.5x faster!)
```

### 2.2 ä½æ©ç æŠ€å·§

**ä½¿ç”¨ä½æ©ç æ›¿ä»£å–æ¨¡è¿ç®—:**

```cpp
// index.hpp:1149, 1154
// âŒ æ…¢ (é™¤æ³•è¿ç®—)
std::size_t index = hash % capacity;
index = (index + 1) % capacity;

// âœ… å¿« (ä½ä¸è¿ç®—, å‰æ: capacityæ˜¯2çš„å¹‚)
std::size_t index = hash & (capacity - 1);
index = (index + 1) & (capacity - 1);
```

**ä¸ºä»€ä¹ˆæ›´å¿«:**

```
å–æ¨¡è¿ç®— (div):
- x86: ~30-40 cycles
- ARM: ~20-30 cycles

ä½ä¸è¿ç®— (and):
- x86: ~1 cycle
- ARM: ~1 cycle

åŠ é€Ÿæ¯”: 30-40x!
```

**é€‚ç”¨åœºæ™¯:**
- âœ… å“ˆå¸Œè¡¨æ§½ä½è®¡ç®—
- âœ… ç¯å½¢ç¼“å†²åŒºç´¢å¼•
- âœ… ä½é›†åˆç´¢å¼•
- âŒ ä»»æ„æ¨¡æ•° (å¿…é¡»æ˜¯2çš„å¹‚)

### 2.3 ç´§å‡‘ç±»å‹: uint40_t

**5å­—èŠ‚æ•´æ•°å®ç° (index.hpp:969-1031):**

```cpp
class usearch_pack_m uint40_t {
    unsigned char octets[5];  // ä»…5å­—èŠ‚!

public:
    // 40ä½å¯è¡¨ç¤º: 2^40 = 1,099,511,627,776 (~1.1ä¸‡äº¿)
    inline uint40_t(std::uint32_t n) noexcept {
        std::memcpy(&octets, &n, 4);
        octets[4] = 0;
    }

#ifdef USEARCH_64BIT_ENV
    inline uint40_t(std::uint64_t n) noexcept {
        std::memcpy(octets, &n, 5);
    }
#endif

    inline operator std::size_t() const noexcept {
        std::size_t result = 0;
#ifdef USEARCH_64BIT_ENV
        std::memcpy(&result, octets, 5);  // åªå¤åˆ¶5å­—èŠ‚
#else
        std::memcpy(&result, octets, 4);
#endif
        return result;
    }

    // æ¯”è¾ƒè¿ç®— (ä»é«˜ä½åˆ°ä½ä½)
    inline bool operator<(uint40_t const& other) const noexcept {
        for (int i = 0; i < 5; ++i) {
            if (octets[4 - i] < other.octets[4 - i])
                return true;
            if (octets[4 - i] > other.octets[4 - i])
                return false;
        }
        return false;
    }
};

static_assert(sizeof(uint40_t) == 5, "Must be exactly 5 bytes");
```

**å†…å­˜èŠ‚çœè®¡ç®—:**

```
å­˜å‚¨1Mä¸ªæ§½ä½å¼•ç”¨:

uint64_t: 1M Ã— 8 bytes = 8 MB
uint40_t: 1M Ã— 5 bytes = 5 MB
èŠ‚çœ: 3 MB (37.5%)

å­˜å‚¨1B (10äº¿) ä¸ªæ§½ä½å¼•ç”¨:
uint64_t: 1B Ã— 8 bytes = 8 GB
uint40_t: 1B Ã— 5 bytes = 5 GB
èŠ‚çœ: 3 GB (37.5%)
```

**é€‚ç”¨èŒƒå›´:**
- å¯è¡¨ç¤º: 0 åˆ° 1,099,511,627,775
- è¶³å¤Ÿè¡¨ç¤ºå•æœºä¸‡äº¿çº§ç‚¹äº‘
- æŒ‰5 bytes/slot + 100 bytes/node â‰ˆ 200TBæ•°æ®

### 2.4 popcountä¼˜åŒ–

**è®¡ç®—äºŒè¿›åˆ¶ä¸­1çš„ä¸ªæ•°:**

```cpp
// âŒ æ…¢ (å¾ªç¯)
int popcount_loop(uint64_t x) {
    int count = 0;
    while (x) {
        count += x & 1;
        x >>= 1;
    }
    return count;
}
// æ—¶é—´: ~64 cycles (æœ€å)

// âœ… å¿« (ç¼–è¯‘å™¨å†…ç½®)
int popcount_builtin(uint64_t x) {
    return __builtin_popcountll(x);
}
// æ—¶é—´: ~1 cycle (x86 POPCNTæŒ‡ä»¤)

// âœ… å¯ç§»æ¤ç‰ˆæœ¬
int popcount_portable(uint64_t x) {
#if defined(__GNUC__) || defined(__clang__)
    return __builtin_popcountll(x);
#elif defined(_MSC_VER)
    return (int)__popcnt64(x);
#else
    // å›é€€åˆ°æŸ¥è¡¨æ³•æˆ–Brian Kernighanç®—æ³•
    int count = 0;
    while (x) {
        x &= x - 1;  // æ¸…é™¤æœ€ä½ä½çš„1
        count++;
    }
    return count;
#endif
}
```

**USearchä¸­çš„åº”ç”¨ (index_plugins.hpp:1411):**

```cpp
// æ±‰æ˜è·ç¦» = ä¸¤ä¸ªä½å‘é‡ä¸åŒä½çš„æ•°é‡
for (std::size_t i = 0; i != words; ++i) {
    matches += std::bitset<bits_per_word_k>(a[i] ^ b[i]).count();
    //                                                   â†‘
    //                                      ç¼–è¯‘å™¨ä¼˜åŒ–ä¸ºPOPCNT
}
```

---

## 3. å¾ªç¯ä¼˜åŒ–ä¸å‘é‡åŒ–

### 3.1 å¾ªç¯å±•å¼€

**æ‰‹åŠ¨å±•å¼€ vs ç¼–è¯‘å™¨å±•å¼€:**

```cpp
// âŒ æœªå±•å¼€ (å¾ªç¯å¼€é”€å¤§)
void add_vectors(float* a, float* b, float* c, size_t n) {
    for (size_t i = 0; i < n; i++) {
        c[i] = a[i] + b[i];
    }
}

// âœ… æ‰‹åŠ¨å±•å¼€4è·¯
void add_vectors_unroll4(float* a, float* b, float* c, size_t n) {
    size_t i = 0;
    // ä¸»å¾ªç¯: æ¯æ¬¡å¤„ç†4ä¸ªå…ƒç´ 
    for (; i + 4 <= n; i += 4) {
        c[i+0] = a[i+0] + b[i+0];
        c[i+1] = a[i+1] + b[i+1];
        c[i+2] = a[i+2] + b[i+2];
        c[i+3] = a[i+3] + b[i+3];
    }
    // å‰©ä½™å…ƒç´ 
    for (; i < n; i++) {
        c[i] = a[i] + b[i];
    }
}

// âœ…âœ… æŒ‡ç¤ºç¼–è¯‘å™¨å±•å¼€
void add_vectors_pragma(float* a, float* b, float* c, size_t n) {
    #pragma GCC unroll 4
    for (size_t i = 0; i < n; i++) {
        c[i] = a[i] + b[i];
    }
}
```

**æ€§èƒ½å¯¹æ¯” (1000ä¸‡å…ƒç´ ):**

| ç‰ˆæœ¬ | æ—¶é—´ | åŠ é€Ÿæ¯” |
|------|------|--------|
| æœªå±•å¼€ | 50ms | 1.0x |
| å±•å¼€2è·¯ | 28ms | 1.8x |
| å±•å¼€4è·¯ | 18ms | 2.8x |
| å±•å¼€8è·¯ | 15ms | 3.3x |
| ç¼–è¯‘å™¨è‡ªåŠ¨ | 17ms | 2.9x |

ğŸ’¡ **å±•å¼€å€æ•°é€‰æ‹©:**
- 2-4è·¯: é€šç”¨
- 8è·¯: é€‚åˆç®€å•æ“ä½œ
- 16è·¯+: å¯èƒ½é€‚å¾—å…¶å (æŒ‡ä»¤ç¼“å­˜å‹åŠ›)

### 3.2 å¾ªç¯åˆå¹¶

**å‡å°‘å¾ªç¯æ¬¡æ•°:**

```cpp
// âŒ ä¸¤æ¬¡éå†æ•°ç»„
void compute_separate(float* data, size_t n) {
    // ç¬¬ä¸€æ¬¡éå†: æ±‚å’Œ
    float sum = 0;
    for (size_t i = 0; i < n; i++) {
        sum += data[i];
    }
    float mean = sum / n;

    // ç¬¬äºŒæ¬¡éå†: è®¡ç®—æ–¹å·®
    float variance = 0;
    for (size_t i = 0; i < n; i++) {
        float diff = data[i] - mean;
        variance += diff * diff;
    }
}

// âœ… ä¸€æ¬¡éå† (Welfordç®—æ³•)
void compute_merged(float* data, size_t n) {
    float mean = 0;
    float M2 = 0;

    for (size_t i = 0; i < n; i++) {
        float delta = data[i] - mean;
        mean += delta / (i + 1);
        float delta2 = data[i] - mean;
        M2 += delta * delta2;
    }

    float variance = M2 / n;
}
```

**USearchä¸­çš„åº”ç”¨ (index_plugins.hpp:1523-1540):**

```cpp
// Pearsonç›¸å…³ç³»æ•° - å•æ¬¡éå†
inline result_t pearson(scalar_t const* a, scalar_t const* b, std::size_t dim) {
    result_t a_sum{}, b_sum{}, ab_sum{};
    result_t a_sq_sum{}, b_sq_sum{};

    #pragma omp simd reduction(+: a_sum, b_sum, ab_sum, a_sq_sum, b_sq_sum)
    for (std::size_t i = 0; i != dim; ++i) {
        result_t ai = a[i];
        result_t bi = b[i];
        a_sum += ai;           // â† 5ä¸ªå½’çº¦åŒæ—¶è¿›è¡Œ
        b_sum += bi;
        ab_sum += ai * bi;
        a_sq_sum += ai * ai;
        b_sq_sum += bi * bi;
    }

    // æœ€åè®¡ç®—ç›¸å…³ç³»æ•°
    result_t corr = dim * ab_sum - a_sum * b_sum;
    result_t denom = (dim * a_sq_sum - a_sum * a_sum) *
                     (dim * b_sq_sum - b_sum * b_sum);
    return 1 - corr / std::sqrt(denom);
}
```

### 3.3 å‘é‡åŒ–å‹å¥½çš„æ•°æ®è®¿é—®

**SoA vs AoS:**

```cpp
// âŒ AoS (Array of Structures) - ä¸åˆ©äºSIMD
struct Point {
    float x, y, z;
};
std::vector<Point> points(1000);

// è®¿é—®xåæ ‡ (è·¨æ­¥è®¿é—®,ç¼“å­˜ä¸å‹å¥½)
for (size_t i = 0; i < points.size(); i++) {
    process(points[i].x);  // xé—´éš”12å­—èŠ‚
}

// âœ… SoA (Structure of Arrays) - SIMDå‹å¥½
struct Points {
    std::vector<float> x;
    std::vector<float> y;
    std::vector<float> z;
};
Points points;
points.x.resize(1000);
points.y.resize(1000);
points.z.resize(1000);

// è®¿é—®xåæ ‡ (è¿ç»­è®¿é—®,å®Œç¾å‘é‡åŒ–)
for (size_t i = 0; i < points.x.size(); i++) {
    process(points.x[i]);  // xè¿ç»­å­˜å‚¨
}
```

**æ€§èƒ½å¯¹æ¯” (100ä¸‡ç‚¹):**

| å¸ƒå±€ | ç¼“å­˜æœªå‘½ä¸­ | SIMDæ•ˆç‡ | é€Ÿåº¦ |
|------|-----------|----------|------|
| AoS | 15% | ä½ | 1.0x |
| SoA | 2% | é«˜ | 4-8x |

---

## 4. å†…å­˜ç®¡ç†ç­–ç•¥

### 4.1 æ™ºèƒ½å®¹é‡å¢é•¿

**USearchçš„å¢é•¿ç­–ç•¥ (index.hpp:1182, 733):**

```cpp
// å“ˆå¸Œè¡¨å¢é•¿: 5/3 å€ (1.67x)
bool reserve(std::size_t new_capacity) noexcept {
    new_capacity = (new_capacity * 5u) / 3u;  // 67%å¢é•¿
    if (new_capacity <= capacity_)
        return true;

    new_capacity = ceil2(new_capacity);  // å‘ä¸Šå–æ•´åˆ°2çš„å¹‚
    // ... é‡æ–°åˆ†é…
}

// å †å¢é•¿: 2å€
bool reserve(std::size_t new_capacity) noexcept {
    new_capacity = ceil2(new_capacity);
    new_capacity = std::max({
        new_capacity,
        capacity_ * 2u,    // è‡³å°‘2å€
        16u                // æœ€å°16ä¸ªå…ƒç´ 
    });
    // ... é‡æ–°åˆ†é…
}
```

**å¢é•¿ç­–ç•¥å¯¹æ¯”:**

| ç­–ç•¥ | æ’å…¥Nä¸ªå…ƒç´ æ€»å¤åˆ¶æ¬¡æ•° | å†…å­˜æµªè´¹ | é€‚ç”¨åœºæ™¯ |
|------|---------------------|---------|---------|
| +1 (å›ºå®šå¢é•¿) | O(NÂ²) | 0% | âŒ æå·® |
| Ã—1.5 | O(N log N) | 50% | âœ… å†…å­˜æ•æ„Ÿ |
| Ã—1.67 | O(N log N) | 67% | âœ… å¹³è¡¡ |
| Ã—2 | O(N) | 100% | âœ… é€Ÿåº¦ä¼˜å…ˆ |
| Ã—4 | O(N) | 300% | âŒ æµªè´¹ |

**ä¸ºä»€ä¹ˆé€‰æ‹©1.67å€?**
- æ¯”2å€èŠ‚çœå†…å­˜
- æ¯”1.5å€æ›´å¿«è¾¾åˆ°ç›®æ ‡å¤§å°
- Ï† (é»„é‡‘æ¯”ä¾‹ 1.618...) é™„è¿‘æ˜¯ç†è®ºæœ€ä¼˜

### 4.2 å†…å­˜å¯¹é½åˆ†é…å™¨

**index_plugins.hpp:807-830**

```cpp
template <typename element_at, std::size_t alignment_ak = 64>
class aligned_allocator_gt {
public:
    using value_type = element_at;
    static constexpr std::size_t alignment() { return alignment_ak; }

    pointer allocate(size_type length) const {
        std::size_t length_bytes = alignment_ak *
            divide_round_up<alignment_ak>(length * sizeof(value_type));

        // é¿å…æ•´æ•°æº¢å‡º
        if (length > length_bytes)
            return nullptr;

#if defined(USEARCH_DEFINED_WINDOWS)
        return (pointer)_aligned_malloc(length_bytes, alignment_ak);
#else
        void* result = nullptr;
        return ::posix_memalign(&result, alignment_ak, length_bytes) == 0
            ? (pointer)result
            : nullptr;
#endif
    }

    void deallocate(pointer ptr, size_type) const {
#if defined(USEARCH_DEFINED_WINDOWS)
        _aligned_free(ptr);
#else
        std::free(ptr);
#endif
    }
};
```

**å¯¹é½çš„é‡è¦æ€§:**

```cpp
// æµ‹è¯•å¯¹é½å½±å“
struct alignas(64) CacheAligned {
    int data[16];
};

struct Unaligned {
    int data[16];
};

// å•çº¿ç¨‹: å·®å¼‚ä¸å¤§
// å¤šçº¿ç¨‹: å¯¹é½ç‰ˆæœ¬å¿«30-50% (é¿å…false sharing)
```

### 4.3 é¢„åˆ†é…ä¸å¤ç”¨

**å‡å°‘åŠ¨æ€åˆ†é…:**

```cpp
// index.hpp:2202
struct usearch_align_m context_t {
    top_candidates_t top_candidates{};
    next_candidates_t next_candidates{};
    visits_hash_set_t visits{};

    // é¢„åˆ†é…å®¹é‡,é¿å…æœç´¢æ—¶é‡æ–°åˆ†é…
    void reserve(size_t capacity) {
        top_candidates.reserve(capacity);
        next_candidates.reserve(capacity);
        visits.reserve(capacity * 2);
    }
};

// ä½¿ç”¨:
std::vector<context_t> thread_contexts(num_threads);
for (auto& ctx : thread_contexts) {
    ctx.reserve(1000);  // é¢„åˆ†é…
}

// æœç´¢æ—¶å¤ç”¨context,é›¶åˆ†é…
void search(size_t thread_id) {
    context_t& ctx = thread_contexts[thread_id];
    ctx.top_candidates.clear();  // æ¸…ç©ºä½†ä¿ç•™å®¹é‡
    // ... ä½¿ç”¨ctx
}
```

**æ€§èƒ½æå‡:**

```
æœªé¢„åˆ†é… (æ¯æ¬¡æœç´¢):
- malloc/free: 15-20 æ¬¡
- æ—¶é—´: 200 ns

é¢„åˆ†é…+å¤ç”¨:
- malloc/free: 0 æ¬¡
- æ—¶é—´: 50 ns

åŠ é€Ÿæ¯”: 4x
```

---

## 5. åˆ†æ”¯æ¶ˆé™¤æŠ€å·§

### 5.1 æ¡ä»¶ç§»åŠ¨æ›¿ä»£åˆ†æ”¯

**ä½¿ç”¨ç®—æœ¯æ›¿ä»£ifè¯­å¥:**

```cpp
// âŒ æœ‰åˆ†æ”¯ (å¯èƒ½åˆ†æ”¯é¢„æµ‹å¤±è´¥)
int max_branching(int a, int b) {
    if (a > b)
        return a;
    else
        return b;
}
// æ±‡ç¼–: cmp, jg, mov, jmp (4-5æ¡æŒ‡ä»¤,æœ‰åˆ†æ”¯)

// âœ… æ— åˆ†æ”¯ (æ¡ä»¶ç§»åŠ¨)
int max_branchless(int a, int b) {
    return a > b ? a : b;
}
// æ±‡ç¼–: cmp, cmovg (2æ¡æŒ‡ä»¤,æ— åˆ†æ”¯)
// GCC/Clangä¼šä¼˜åŒ–ä¸ºcmovæŒ‡ä»¤
```

**USearchä¸­çš„åº”ç”¨ (index_plugins.hpp:1500-1503):**

```cpp
// Jaccardç›¸ä¼¼åº¦è®¡ç®— - å·§å¦™é¿å…åˆ†æ”¯
inline result_t jaccard(
    scalar_t const* a, scalar_t const* b,
    std::size_t a_length, std::size_t b_length
) const noexcept {
    std::size_t intersection{}, i{}, j{};

    while (i != a_length && j != b_length) {
        scalar_t ai = a[i];
        scalar_t bj = b[j];

        // âœ… æ— åˆ†æ”¯ç‰ˆæœ¬
        intersection += ai == bj;   // 0æˆ–1
        i += ai < bj;                // å¢é‡0æˆ–1
        j += ai >= bj;               // å¢é‡0æˆ–1

        // ç­‰ä»·äºæœ‰åˆ†æ”¯ç‰ˆæœ¬:
        // if (ai == bj) {
        //     intersection++;
        //     i++; j++;
        // } else if (ai < bj) {
        //     i++;
        // } else {
        //     j++;
        // }
    }

    return 1 - (float)intersection / (a_length + b_length - intersection);
}
```

**æ€§èƒ½å¯¹æ¯” (100ä¸‡æ¬¡è°ƒç”¨):**

| ç‰ˆæœ¬ | æ—¶é—´ | åˆ†æ”¯é¢„æµ‹å¤±è´¥ |
|------|------|-------------|
| æœ‰åˆ†æ”¯ | 35ms | 25% |
| æ— åˆ†æ”¯ | 22ms | 0% |
| **åŠ é€Ÿ** | **1.6x** | |

### 5.2 æŸ¥è¡¨æ³•

**é¢„è®¡ç®—æ›¿ä»£è¿è¡Œæ—¶åˆ¤æ–­:**

```cpp
// âŒ æ¯æ¬¡è®¡ç®— (æœ‰åˆ†æ”¯)
int get_scalar_size_branching(scalar_kind_t kind) {
    if (kind == scalar_kind_t::f64_k) return 8;
    if (kind == scalar_kind_t::f32_k) return 4;
    if (kind == scalar_kind_t::f16_k) return 2;
    if (kind == scalar_kind_t::i8_k) return 1;
    return 0;
}

// âœ… æŸ¥è¡¨ (æ— åˆ†æ”¯)
constexpr int scalar_sizes[] = {
    [scalar_kind_t::f64_k] = 8,
    [scalar_kind_t::f32_k] = 4,
    [scalar_kind_t::f16_k] = 2,
    [scalar_kind_t::i8_k] = 1,
};

int get_scalar_size_lut(scalar_kind_t kind) {
    return scalar_sizes[static_cast<int>(kind)];
}
```

**æ›´å¤æ‚çš„ä¾‹å­: è·ç¦»å‡½æ•°åˆ†æ´¾:**

```cpp
// index_plugins.hpp:1738
using distance_func_t = float(*)(const void*, const void*, size_t);

static distance_func_t distance_functions[NUM_METRICS][NUM_SCALARS] = {
    // [metric][scalar] = function pointer
    [metric_kind_t::cos_k][scalar_kind_t::f32_k] = &cos_f32,
    [metric_kind_t::cos_k][scalar_kind_t::f16_k] = &cos_f16,
    // ...
};

// ä½¿ç”¨: ä¸€æ¬¡æŸ¥è¡¨,é›¶åˆ†æ”¯
auto func = distance_functions[metric][scalar];
float dist = func(a, b, dim);
```

---

## 6. æ•°æ®ç»“æ„ç´§å‡‘æ€§

### 6.1 Bit Packing

**èŠ‚çœå†…å­˜çš„ä½åŸŸ:**

```cpp
// âŒ æµªè´¹å†…å­˜ (12 bytes)
struct NodeInfo {
    bool visited;        // 1 byte (æµªè´¹7 bits)
    bool locked;         // 1 byte (æµªè´¹7 bits)
    uint8_t level;       // 1 byte
    uint32_t parent;     // 4 bytes
    uint32_t distance;   // 4 bytes
    // æ€»è®¡: 12 bytes (å®é™…åªéœ€10.25 bytes)
};

// âœ… ç´§å‡‘å¸ƒå±€ (8 bytes)
struct NodeInfoPacked {
    uint64_t visited : 1;     // 1 bit
    uint64_t locked : 1;      // 1 bit
    uint64_t level : 6;       // 6 bits (æœ€å¤§63å±‚)
    uint64_t parent : 28;     // 28 bits (æœ€å¤§268MèŠ‚ç‚¹)
    uint64_t distance : 28;   // 28 bits
    // æ€»è®¡: 64 bits = 8 bytes
};

// 100ä¸‡èŠ‚ç‚¹:
// æœªä¼˜åŒ–: 12 MB
// ä¼˜åŒ–å: 8 MB
// èŠ‚çœ: 33%
```

**USearchä¸­çš„bitsetå®ç° (index.hpp:470-527):**

```cpp
template <typename allocator_at = std::allocator<byte_t>>
class bitset_gt {
    using compressed_slot_t = std::uint32_t;
    using word_t = std::uint64_t;  // 64ä½å­—

    word_t* slots_;
    std::size_t count_;  // å­—æ•°,ä¸æ˜¯ä½æ•°

    static constexpr std::size_t bits_per_word() {
        return sizeof(word_t) * 8;  // 64
    }

    static std::size_t slots(std::size_t capacity) {
        return divide_round_up<bits_per_word()>(capacity);
    }

public:
    // è®¾ç½®ç¬¬slotä½
    inline bool set(compressed_slot_t slot) noexcept {
        std::size_t word_idx = slot / bits_per_word();
        std::size_t bit_idx = slot % bits_per_word();
        word_t mask = word_t(1) << bit_idx;

        word_t old_word = slots_[word_idx];
        slots_[word_idx] |= mask;
        return (old_word & mask) != 0;  // è¿”å›æ—§å€¼
    }

    // é‡ç½®ç¬¬slotä½
    inline void reset(compressed_slot_t slot) noexcept {
        std::size_t word_idx = slot / bits_per_word();
        std::size_t bit_idx = slot % bits_per_word();
        word_t mask = ~(word_t(1) << bit_idx);
        slots_[word_idx] &= mask;
    }

    // æµ‹è¯•ç¬¬slotä½
    inline bool test(compressed_slot_t slot) const noexcept {
        std::size_t word_idx = slot / bits_per_word();
        std::size_t bit_idx = slot % bits_per_word();
        word_t mask = word_t(1) << bit_idx;
        return (slots_[word_idx] & mask) != 0;
    }
};
```

**å†…å­˜èŠ‚çœ (1MèŠ‚ç‚¹é”):**

```
std::mutex[1M]: 1M Ã— 40 bytes = 40 MB
bitset<1M>:     1M / 64 Ã— 8 = 125 KB
èŠ‚çœ: 99.7%!
```

### 6.2 ç»“æ„ä½“å¸ƒå±€ä¼˜åŒ–

**é¿å…å†…å­˜ç©ºæ´:**

```cpp
// âŒ æœ‰å†…å­˜ç©ºæ´ (24 bytes)
struct BadLayout {
    char a;      // 1 byte
                 // 3 bytes padding
    int b;       // 4 bytes
    char c;      // 1 byte
                 // 7 bytes padding
    double d;    // 8 bytes
};
sizeof(BadLayout) == 24

// âœ… ä¼˜åŒ–å (16 bytes)
struct GoodLayout {
    double d;    // 8 bytes
    int b;       // 4 bytes
    char a;      // 1 byte
    char c;      // 1 byte
                 // 2 bytes padding (unavoidable)
};
sizeof(GoodLayout) == 16

// èŠ‚çœ: 33%
```

**è‡ªåŠ¨åŒ–å·¥å…·:**

```bash
# GCC: æ˜¾ç¤ºç»“æ„ä½“å¸ƒå±€
g++ -fdump-tree-original -c struct.cpp
cat struct.cpp.* | grep -A20 "struct BadLayout"

# Clang: æ˜¾ç¤ºpadding
clang++ -Xclang -fdump-record-layouts struct.cpp

# paholeå·¥å…· (Linux)
pahole -C BadLayout ./program
```

**USearchçš„ä¼˜åŒ– (index.hpp:959):**

```cpp
#if defined(USEARCH_DEFINED_WINDOWS)
#pragma pack(push, 1)  // ç´§å‡‘æ‰“åŒ…
#endif

class usearch_pack_m uint40_t {
    unsigned char octets[5];  // æ— padding
    // ...
};

#if defined(USEARCH_DEFINED_WINDOWS)
#pragma pack(pop)
#endif

static_assert(sizeof(uint40_t) == 5, "Must be exactly 5 bytes");
```

---

## 7. ç±»å‹ç³»ç»Ÿä¼˜åŒ–

### 7.1 SFINAEä¼˜åŒ–ç¼–è¯‘æœŸåˆ†æ´¾

**æ ¹æ®ç±»å‹ç‰¹æ€§é€‰æ‹©å®ç°:**

```cpp
// index.hpp:228-241
template <typename at, typename sfinae_at = at>
typename std::enable_if<std::is_pod<sfinae_at>::value>::type
destroy_at(at*) {
    // PODç±»å‹: ä¸éœ€è¦è°ƒç”¨ææ„å‡½æ•°
}

template <typename at, typename sfinae_at = at>
typename std::enable_if<!std::is_pod<sfinae_at>::value>::type
destroy_at(at* obj) {
    // éPODç±»å‹: è°ƒç”¨ææ„å‡½æ•°
    obj->~sfinae_at();
}
```

**æ›´å¤æ‚çš„ä¾‹å­:**

```cpp
// index.hpp:1043-1057
template <typename element_at>
struct default_free_value_gt {
    // æ•´æ•°ç±»å‹: è¿”å›æœ€å¤§å€¼
    template <typename T = element_at>
    static typename std::enable_if<std::is_integral<T>::value, T>::type
    value() noexcept {
        return std::numeric_limits<T>::max();
    }

    // æµ®ç‚¹ç±»å‹: è¿”å›NaN
    template <typename T = element_at>
    static typename std::enable_if<std::is_floating_point<T>::value, T>::type
    value() noexcept {
        return std::numeric_limits<T>::quiet_NaN();
    }

    // æŒ‡é’ˆç±»å‹: è¿”å›nullptr
    template <typename T = element_at>
    static typename std::enable_if<std::is_pointer<T>::value, T>::type
    value() noexcept {
        return nullptr;
    }
};
```

**æ€§èƒ½ä¼˜åŠ¿:**
- âœ… ç¼–è¯‘æœŸå†³ç­–,é›¶è¿è¡Œæ—¶å¼€é”€
- âœ… ç±»å‹å®‰å…¨
- âœ… è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜å®ç°

### 7.2 constexprç¼–è¯‘æœŸè®¡ç®—

**ç¼–è¯‘æœŸå¸¸é‡æŠ˜å :**

```cpp
// âŒ è¿è¡Œæ—¶è®¡ç®—
int bits_per_word() {
    return sizeof(uint64_t) * 8;
}

// âœ… ç¼–è¯‘æœŸè®¡ç®—
constexpr int bits_per_word() {
    return sizeof(uint64_t) * 8;
}

// ä½¿ç”¨
for (size_t i = 0; i < bits_per_word(); i++) {
    // ç¼–è¯‘å™¨ç›´æ¥å†…è”å¸¸é‡64,æ— å‡½æ•°è°ƒç”¨
}
```

**USearchçš„åº”ç”¨ (index_plugins.hpp:1401):**

```cpp
template <typename scalar_at, typename result_at>
struct metric_hamming_gt {
    inline result_t operator()(
        scalar_t const* a,
        scalar_t const* b,
        std::size_t words
    ) const noexcept {
        constexpr std::size_t bits_per_word_k = sizeof(scalar_t) * CHAR_BIT;
        //        â†‘ ç¼–è¯‘æœŸå¸¸é‡

        result_t matches{};
        for (std::size_t i = 0; i != words; ++i) {
            matches += std::bitset<bits_per_word_k>(a[i] ^ b[i]).count();
            //                      â†‘ ç¼–è¯‘æœŸå·²çŸ¥å¤§å°,ä¼˜åŒ–æ›´å¥½
        }
        return matches;
    }
};
```

### 7.3 Trivial Typesä¼˜åŒ–

**åˆ©ç”¨trivialç‰¹æ€§:**

```cpp
// index.hpp:672-673
static_assert(std::is_trivially_destructible<element_t>(),
              "This heap is designed for trivial structs");
static_assert(std::is_trivially_copy_constructible<element_t>(),
              "This heap is designed for trivial structs");

// å¥½å¤„:
// 1. å¯ä»¥ç”¨memcpyä»£æ›¿é€ä¸ªå¤åˆ¶
// 2. ææ„æ—¶å¯ä»¥ç›´æ¥é‡Šæ”¾å†…å­˜,ä¸è°ƒç”¨ææ„å‡½æ•°
// 3. ç§»åŠ¨=å¤åˆ¶,æ— éœ€ç‰¹æ®Šå¤„ç†

// ä½¿ç”¨memcpyä¼˜åŒ–
if (elements_) {
    std::memcpy(new_elements, elements_, size_ * sizeof(element_t));
    allocator.deallocate(elements_, capacity_);
}
```

**æ€§èƒ½å¯¹æ¯” (å¤åˆ¶100ä¸‡å…ƒç´ ):**

| æ–¹æ³• | æ—¶é—´ |
|------|------|
| å¾ªç¯å¤åˆ¶ | 50ms |
| std::copy | 35ms |
| memcpy (trivial) | 12ms |
| **åŠ é€Ÿ** | **4.2x** |

---

## 8. ç¼–è¯‘æœŸè®¡ç®—

### 8.1 æ¨¡æ¿å…ƒç¼–ç¨‹

**ç¼–è¯‘æœŸé˜¶ä¹˜:**

```cpp
template <unsigned N>
struct Factorial {
    static constexpr unsigned value = N * Factorial<N-1>::value;
};

template <>
struct Factorial<0> {
    static constexpr unsigned value = 1;
};

// ä½¿ç”¨
constexpr unsigned fact5 = Factorial<5>::value;  // 120 (ç¼–è¯‘æœŸè®¡ç®—!)
```

**USearchä¸­çš„ç¼–è¯‘æœŸé™¤æ³• (index.hpp:177):**

```cpp
template <std::size_t multiple_ak>
std::size_t divide_round_up(std::size_t num) noexcept {
    return (num + multiple_ak - 1) / multiple_ak;
}

// è°ƒç”¨æ—¶multiple_akæ˜¯æ¨¡æ¿å‚æ•°,ç¼–è¯‘æœŸå·²çŸ¥
// ç¼–è¯‘å™¨ä¼šä¼˜åŒ–é™¤æ³•ä¸ºä½ç§» (å¦‚æœæ˜¯2çš„å¹‚)

// ä¾‹å¦‚: divide_round_up<64>(n)
// ç¼–è¯‘ä¸º: (n + 63) >> 6
```

### 8.2 constexprå‡½æ•°

**å¤æ‚ç¼–è¯‘æœŸè®¡ç®—:**

```cpp
// C++14: constexprå‡½æ•°å¯ä»¥åŒ…å«å¾ªç¯å’Œæ¡ä»¶
constexpr size_t fibonacci(size_t n) {
    if (n <= 1) return n;

    size_t a = 0, b = 1;
    for (size_t i = 2; i <= n; i++) {
        size_t tmp = a + b;
        a = b;
        b = tmp;
    }
    return b;
}

// ç¼–è¯‘æœŸè®¡ç®—
constexpr size_t fib20 = fibonacci(20);  // ç¼–è¯‘ä¸ºå¸¸é‡6765

// ä¹Ÿå¯è¿è¡Œæ—¶è®¡ç®—
size_t n = read_input();
size_t result = fibonacci(n);  // è¿è¡Œæ—¶è®¡ç®—
```

---

## 9. å¹³å°ç‰¹å®šä¼˜åŒ–

### 9.1 CPUç‰¹æ€§æ£€æµ‹

**è¿è¡Œæ—¶æ£€æµ‹SIMDæ”¯æŒ:**

```cpp
#include <cpuid.h>

struct CPUFeatures {
    bool has_sse2 = false;
    bool has_avx = false;
    bool has_avx2 = false;
    bool has_avx512 = false;

    CPUFeatures() {
#if defined(__x86_64__) || defined(_M_X64)
        unsigned int eax, ebx, ecx, edx;

        // CPUID function 1
        __get_cpuid(1, &eax, &ebx, &ecx, &edx);
        has_sse2 = (edx & bit_SSE2) != 0;
        has_avx = (ecx & bit_AVX) != 0;

        // CPUID function 7
        __get_cpuid_count(7, 0, &eax, &ebx, &ecx, &edx);
        has_avx2 = (ebx & bit_AVX2) != 0;
        has_avx512 = (ebx & bit_AVX512F) != 0;
#endif
    }
};

// ä½¿ç”¨
CPUFeatures cpu;
if (cpu.has_avx512) {
    use_avx512_implementation();
} else if (cpu.has_avx2) {
    use_avx2_implementation();
} else {
    use_scalar_implementation();
}
```

**SimSIMDçš„æ–¹æ³• (index_plugins.hpp:73):**

```cpp
#if USEARCH_USE_SIMSIMD
    simsimd_capability_t capability = simsimd_capabilities();
    // è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜SIMDå®ç°
#endif
```

### 9.2 å¹³å°å®å®šä¹‰

**USearchçš„è·¨å¹³å°æ£€æµ‹ (index.hpp:22-54):**

```cpp
// æ“ä½œç³»ç»Ÿæ£€æµ‹
#if defined(WIN32) || defined(_WIN32)
    #define USEARCH_DEFINED_WINDOWS
#elif defined(__APPLE__) && defined(__MACH__)
    #define USEARCH_DEFINED_APPLE
#elif defined(__linux__)
    #define USEARCH_DEFINED_LINUX
#endif

// ç¼–è¯‘å™¨æ£€æµ‹
#if defined(__clang__)
    #define USEARCH_DEFINED_CLANG
#elif defined(__GNUC__)
    #define USEARCH_DEFINED_GCC
#endif

// æ¶æ„æ£€æµ‹
#if defined(__x86_64__)
    #define USEARCH_DEFINED_X86
#elif defined(__aarch64__)
    #define USEARCH_DEFINED_ARM
#endif

// ä½å®½æ£€æµ‹
#if defined(_WIN64) || defined(__LP64__)
    #define USEARCH_64BIT_ENV
#else
    #define USEARCH_32BIT_ENV
#endif
```

### 9.3 æ¡ä»¶ç¼–è¯‘ä¼˜åŒ–

**æ ¹æ®å¹³å°é€‰æ‹©å®ç°:**

```cpp
// index.hpp:72-85
#if defined(USEARCH_DEFINED_WINDOWS)
    #include <Windows.h>
    #include <sys/stat.h>
#else
    #include <fcntl.h>
    #include <sys/mman.h>
    #include <sys/stat.h>
    #include <unistd.h>
#endif

// å†…å­˜åˆ†é…
void* aligned_alloc(size_t alignment, size_t size) {
#if defined(USEARCH_DEFINED_WINDOWS)
    return _aligned_malloc(size, alignment);
#else
    void* result = nullptr;
    posix_memalign(&result, alignment, size);
    return result;
#endif
}
```

---

## 10. å¾®æ¶æ„çº§ä¼˜åŒ–

### 10.1 å‡å°‘ä¾èµ–é“¾

**æ‰“ç ´æ•°æ®ä¾èµ–:**

```cpp
// âŒ é•¿ä¾èµ–é“¾
float sum_dependent(float* data, size_t n) {
    float sum = 0.0f;
    for (size_t i = 0; i < n; i++) {
        sum += data[i];  // æ¯æ¬¡åŠ æ³•ä¾èµ–å‰ä¸€æ¬¡ç»“æœ
    }
    return sum;
}
// å»¶è¿Ÿ: n Ã— åŠ æ³•å»¶è¿Ÿ (3-5 cycles)

// âœ… å¤šè·¯ç´¯åŠ ,å‡å°‘ä¾èµ–
float sum_independent(float* data, size_t n) {
    float sum0 = 0, sum1 = 0, sum2 = 0, sum3 = 0;

    size_t i = 0;
    for (; i + 4 <= n; i += 4) {
        sum0 += data[i+0];  // 4æ¡ç‹¬ç«‹çš„ä¾èµ–é“¾
        sum1 += data[i+1];
        sum2 += data[i+2];
        sum3 += data[i+3];
    }

    // æœ€ååˆå¹¶
    return (sum0 + sum1) + (sum2 + sum3) + tail_sum(data + i, n - i);
}
// å»¶è¿Ÿ: (n/4) Ã— åŠ æ³•å»¶è¿Ÿ â†’ 4å€åŠ é€Ÿ!
```

**å®é™…æ€§èƒ½ (1Må…ƒç´ ):**

| ç‰ˆæœ¬ | æ—¶é—´ | IPC |
|------|------|-----|
| ä¾èµ–é“¾ | 12ms | 0.5 |
| 4è·¯ç´¯åŠ  | 3ms | 2.0 |
| **åŠ é€Ÿ** | **4x** | |

### 10.2 æŒ‡ä»¤çº§å¹¶è¡Œ (ILP)

**å……åˆ†åˆ©ç”¨CPUæµæ°´çº¿:**

```cpp
// âŒ ILPä½ (æ¯æ¬¡è¿­ä»£ä¾èµ–å‰ä¸€æ¬¡)
void process_sequential(int* data, size_t n) {
    for (size_t i = 0; i < n; i++) {
        data[i] = compute(data[i]);  // ä¾èµ–è‡ªå·±
    }
}

// âœ… ILPé«˜ (ç‹¬ç«‹æ“ä½œå¯å¹¶è¡Œæ‰§è¡Œ)
void process_parallel(int* a, int* b, int* c, size_t n) {
    for (size_t i = 0; i < n; i++) {
        int tmp_a = load(a[i]);      // å¯å¹¶è¡Œ
        int tmp_b = load(b[i]);      // å¯å¹¶è¡Œ
        int result = tmp_a + tmp_b;  // ä¾èµ–load
        store(c[i], result);         // ä¾èµ–add
    }
    // CPUå¯ä»¥åŒæ—¶æ‰§è¡Œå¤šä¸ªloadæŒ‡ä»¤
}
```

### 10.3 é¿å…Store-to-Loadè½¬å‘å¤±è´¥

**å¯¹é½å†™åè¯»:**

```cpp
// âŒ å¯èƒ½å¯¼è‡´è½¬å‘å¤±è´¥
void bad_store_load() {
    int* ptr = allocate();
    *ptr = 42;                // å­˜å‚¨4å­—èŠ‚
    long long value = *(long long*)ptr;  // è¯»å–8å­—èŠ‚ - æœªå¯¹é½!
    // CPUæ— æ³•æ­£ç¡®è½¬å‘,å¯¼è‡´é¢å¤–20+ cycleså»¶è¿Ÿ
}

// âœ… å¯¹é½è®¿é—®
void good_store_load() {
    long long* ptr = allocate_aligned();
    *ptr = 42;                // å­˜å‚¨8å­—èŠ‚
    long long value = *ptr;   // è¯»å–8å­—èŠ‚ - å®Œç¾åŒ¹é…
    // CPUå¯ä»¥å¿«é€Ÿè½¬å‘,ä»…3-5 cycles
}
```

---

## 11. æ€§èƒ½æµ‹é‡æ–¹æ³•

### 11.1 å¾®åŸºå‡†æµ‹è¯•

**ä½¿ç”¨Google Benchmark:**

```cpp
#include <benchmark/benchmark.h>

static void BM_VectorAdd(benchmark::State& state) {
    std::vector<float> a(state.range(0));
    std::vector<float> b(state.range(0));
    std::vector<float> c(state.range(0));

    // åˆå§‹åŒ–æ•°æ®
    std::fill(a.begin(), a.end(), 1.0f);
    std::fill(b.begin(), b.end(), 2.0f);

    for (auto _ : state) {
        // è¢«æµ‹ä»£ç 
        for (size_t i = 0; i < a.size(); i++) {
            c[i] = a[i] + b[i];
        }

        // é˜²æ­¢ç¼–è¯‘å™¨ä¼˜åŒ–æ‰
        benchmark::DoNotOptimize(c.data());
        benchmark::ClobberMemory();
    }

    // æŠ¥å‘Šååé‡
    state.SetItemsProcessed(state.iterations() * state.range(0));
}

BENCHMARK(BM_VectorAdd)->Range(1<<10, 1<<20);  // 1Kåˆ°1Må…ƒç´ 
BENCHMARK_MAIN();
```

**è¿è¡Œç»“æœ:**

```
---------------------------------------------------------------
Benchmark                     Time             CPU   Iterations
---------------------------------------------------------------
BM_VectorAdd/1024          652 ns          652 ns      1073283
BM_VectorAdd/4096         2604 ns         2604 ns       268817
BM_VectorAdd/16384       10413 ns        10413 ns        67205
BM_VectorAdd/65536       41650 ns        41650 ns        16801
```

### 11.2 perfå·¥å…·é“¾

**CPUæ€§èƒ½è®¡æ•°å™¨:**

```bash
# åŸºç¡€ç»Ÿè®¡
perf stat ./program

# è¯¦ç»†äº‹ä»¶
perf stat -e cycles,instructions,cache-misses,branch-misses ./program

# è¾“å‡ºç¤ºä¾‹:
#  Performance counter stats for './program':
#
#      2,345,678,901      cycles
#      3,456,789,012      instructions          (1.48 IPC)
#         12,345,678      cache-misses          (5.3%)
#          1,234,567      branch-misses         (2.1%)

# CPUé‡‡æ ·
perf record -g -F 999 ./program
perf report

# ç”Ÿæˆç«ç„°å›¾
perf script | stackcollapse-perf.pl | flamegraph.pl > flame.svg
```

### 11.3 ç¼“å­˜æ€§èƒ½åˆ†æ

```bash
# è¯¦ç»†ç¼“å­˜ç»Ÿè®¡
perf stat -e \
  L1-dcache-loads,L1-dcache-load-misses,\
  L1-dcache-stores,L1-dcache-store-misses,\
  LLC-loads,LLC-load-misses,\
  LLC-stores,LLC-store-misses \
  ./program

# Cachegrind (Valgrindå·¥å…·)
valgrind --tool=cachegrind --cache-sim=yes ./program
cg_annotate cachegrind.out.12345

# è¾“å‡ºç¤ºä¾‹:
# I   refs:      1,234,567,890
# I1  misses:        1,234,567  (0.1%)
# LLi misses:          123,456  (0.01%)
# D   refs:        987,654,321
# D1  misses:       12,345,678  (1.25%)
# LLd misses:        1,234,567  (0.13%)
```

### 11.4 åˆ†æ”¯é¢„æµ‹åˆ†æ

```bash
# åˆ†æ”¯é¢„æµ‹ç»Ÿè®¡
perf stat -e \
  branches,\
  branch-misses,\
  branch-loads,\
  branch-load-misses \
  ./program

# ç›®æ ‡:
# - åˆ†æ”¯é¢„æµ‹å¤±è´¥ç‡ < 5%
# - çƒ­ç‚¹å¾ªç¯ < 1%
```

---

## 12. åæ¨¡å¼è­¦ç¤º

### 12.1 è¿‡æ—©ä¼˜åŒ–

**âŒ é”™è¯¯ç¤ºä¾‹:**

```cpp
// åœ¨ä¸çŸ¥é“ç“¶é¢ˆçš„æƒ…å†µä¸‹è¿‡åº¦ä¼˜åŒ–
class OverOptimized {
    // ä½¿ç”¨å¤æ‚çš„å†…å­˜æ± 
    custom_pool_allocator pool_;

    // æ‰‹åŠ¨SIMD (éš¾ç»´æŠ¤)
    __m256 simd_data[100];

    // ä½åŸŸæ‰“åŒ… (éš¾è°ƒè¯•)
    struct {
        uint64_t flag1 : 1;
        uint64_t flag2 : 1;
        uint64_t data : 62;
    } packed;
};

// é—®é¢˜:
// 1. æ²¡æœ‰profilingæ•°æ®æ”¯æ’‘
// 2. ä»£ç å¤æ‚åº¦å¤§å¢
// 3. å¯èƒ½ä¼˜åŒ–äº†éç“¶é¢ˆéƒ¨åˆ†
```

**âœ… æ­£ç¡®æµç¨‹:**

```
1. å®ç°åŠŸèƒ½æ­£ç¡®ç‰ˆæœ¬
2. Profileæ‰¾å‡ºç“¶é¢ˆ
3. ä¼˜åŒ–ç“¶é¢ˆ
4. æµ‹é‡éªŒè¯
5. é‡å¤2-4
```

### 12.2 å¿½ç•¥å¤§Oå¤æ‚åº¦

**âŒ å¾®ä¼˜åŒ–æ— æ„ä¹‰:**

```cpp
// O(NÂ²) ç®—æ³•,å³ä½¿æ¯æ­¥ä¼˜åŒ–10å€ä¹Ÿèµ¶ä¸ä¸ŠO(N log N)
void bubble_sort_optimized(int* arr, int n) {
    // ä½¿ç”¨äº†æ‰€æœ‰æŠ€å·§: SIMD, å¾ªç¯å±•å¼€, æ— åˆ†æ”¯...
    // ä½†ä¾ç„¶æ˜¯O(NÂ²)
    // N=100ä¸‡æ—¶: ~1ä¸‡äº¿æ¬¡æ“ä½œ
}

void quick_sort(int* arr, int n) {
    // æ ‡å‡†å®ç°,æ²¡æœ‰ç‰¹æ®Šä¼˜åŒ–
    // O(N log N)
    // N=100ä¸‡æ—¶: ~2åƒä¸‡æ¬¡æ“ä½œ
    // å¿«500å€!
}
```

**æ•™è®­:** å…ˆä¼˜åŒ–ç®—æ³•,å†ä¼˜åŒ–å®ç°

### 12.3 å†…å­˜åˆ†é…åœ¨çƒ­è·¯å¾„

**âŒ æ€§èƒ½æ€æ‰‹:**

```cpp
void process_requests() {
    for (auto& request : requests) {
        // æ¯æ¬¡åˆ†é…æ–°vector - ç¾éš¾!
        std::vector<int> temp_buffer;
        temp_buffer.reserve(1000);
        // å¤„ç†...
    }
}
// 100ä¸‡è¯·æ±‚ = 100ä¸‡æ¬¡malloc/free
// æ—¶é—´: ~500ms

âœ… å¤ç”¨å†…å­˜:
void process_requests_optimized() {
    std::vector<int> temp_buffer;
    temp_buffer.reserve(1000);  // åªåˆ†é…ä¸€æ¬¡

    for (auto& request : requests) {
        temp_buffer.clear();  // æ¸…ç©ºä½†ä¿ç•™å®¹é‡
        // å¤„ç†...
    }
}
// æ—¶é—´: ~50ms (10å€åŠ é€Ÿ!)
```

### 12.4 å¿½ç•¥ç¼–è¯‘å™¨ä¼˜åŒ–çº§åˆ«

**ç¼–è¯‘é€‰é¡¹çš„é‡è¦æ€§:**

```bash
# âŒ Debugæ„å»ºç”¨äºç”Ÿäº§
g++ -O0 -g program.cpp -o program_debug
# é€Ÿåº¦: 1x (åŸºå‡†)

# âœ… Releaseæ„å»º
g++ -O3 -march=native -DNDEBUG program.cpp -o program_release
# é€Ÿåº¦: 10-50x faster!

# âœ…âœ… æé™ä¼˜åŒ– (PGO)
g++ -O3 -march=native -fprofile-generate program.cpp -o program_prof
./program_prof  # æ”¶é›†profileæ•°æ®
g++ -O3 -march=native -fprofile-use program.cpp -o program_optimized
# é€Ÿåº¦: é¢å¤–10-20%æå‡
```

### 12.5 ä¸æµ‹é‡å°±å‡è®¾

**å¸¸è§è¯¯åŒº:**

```cpp
// âŒ å‡è®¾: "æ•´æ•°è¿ç®—æ¯”æµ®ç‚¹å¿«"
// ç°å®: ç°ä»£CPUçš„FPååé‡å¯èƒ½æ›´é«˜

// âŒ å‡è®¾: "å†…è”å‡½æ•°ä¸€å®šæ›´å¿«"
// ç°å®: è¿‡åº¦å†…è”å¯¼è‡´I-cache missæ›´æ…¢

// âŒ å‡è®¾: "æ‰‹å†™SIMDæ¯”ç¼–è¯‘å™¨è‡ªåŠ¨å‘é‡åŒ–å¿«"
// ç°å®: GCC/Clangçš„è‡ªåŠ¨å‘é‡åŒ–å¾ˆå¼ºå¤§

// âœ… æ­£ç¡®åšæ³•: æµ‹é‡å¯¹æ¯”
benchmark_integer_version();
benchmark_float_version();
// ç»“æœå¯èƒ½å‡ºäººæ„æ–™!
```

---

## 13. ç»¼åˆæ¡ˆä¾‹ç ”ç©¶

### æ¡ˆä¾‹1: å‘é‡è·ç¦»è®¡ç®—ä¼˜åŒ–

**åˆå§‹ç‰ˆæœ¬ (æœªä¼˜åŒ–):**

```cpp
float cosine_v0(const float* a, const float* b, size_t n) {
    float dot = 0, norm_a = 0, norm_b = 0;
    for (size_t i = 0; i < n; i++) {
        dot += a[i] * b[i];
        norm_a += a[i] * a[i];
        norm_b += b[i] * b[i];
    }
    return 1.0f - dot / (sqrtf(norm_a) * sqrtf(norm_b));
}
// æ€§èƒ½: 1000 ns (768ç»´)
```

**ä¼˜åŒ–1: å¾ªç¯å±•å¼€**

```cpp
float cosine_v1(const float* a, const float* b, size_t n) {
    float dot0 = 0, dot1 = 0, dot2 = 0, dot3 = 0;
    float norm_a0 = 0, norm_a1 = 0, norm_a2 = 0, norm_a3 = 0;
    float norm_b0 = 0, norm_b1 = 0, norm_b2 = 0, norm_b3 = 0;

    size_t i = 0;
    for (; i + 4 <= n; i += 4) {
        dot0 += a[i+0] * b[i+0];
        dot1 += a[i+1] * b[i+1];
        dot2 += a[i+2] * b[i+2];
        dot3 += a[i+3] * b[i+3];

        norm_a0 += a[i+0] * a[i+0];
        norm_a1 += a[i+1] * a[i+1];
        norm_a2 += a[i+2] * a[i+2];
        norm_a3 += a[i+3] * a[i+3];

        norm_b0 += b[i+0] * b[i+0];
        norm_b1 += b[i+1] * b[i+1];
        norm_b2 += b[i+2] * b[i+2];
        norm_b3 += b[i+3] * b[i+3];
    }

    float dot = dot0 + dot1 + dot2 + dot3;
    float norm_a = norm_a0 + norm_a1 + norm_a2 + norm_a3;
    float norm_b = norm_b0 + norm_b1 + norm_b2 + norm_b3;

    // å¤„ç†å‰©ä½™å…ƒç´ ...

    return 1.0f - dot / (sqrtf(norm_a) * sqrtf(norm_b));
}
// æ€§èƒ½: 400 ns (2.5x faster)
```

**ä¼˜åŒ–2: AVX2 SIMD**

```cpp
#include <immintrin.h>

float cosine_v2(const float* a, const float* b, size_t n) {
    __m256 sum_dot = _mm256_setzero_ps();
    __m256 sum_a2 = _mm256_setzero_ps();
    __m256 sum_b2 = _mm256_setzero_ps();

    size_t i = 0;
    for (; i + 8 <= n; i += 8) {
        __m256 va = _mm256_loadu_ps(a + i);
        __m256 vb = _mm256_loadu_ps(b + i);

        sum_dot = _mm256_fmadd_ps(va, vb, sum_dot);
        sum_a2 = _mm256_fmadd_ps(va, va, sum_a2);
        sum_b2 = _mm256_fmadd_ps(vb, vb, sum_b2);
    }

    // æ°´å¹³æ±‚å’Œ
    float dot = hsum256_ps(sum_dot);
    float norm_a = hsum256_ps(sum_a2);
    float norm_b = hsum256_ps(sum_b2);

    // å¤„ç†å‰©ä½™å…ƒç´ ...

    return 1.0f - dot / (sqrtf(norm_a) * sqrtf(norm_b));
}
// æ€§èƒ½: 120 ns (8.3x faster)
```

**ä¼˜åŒ–3: AVX-512 + FMA**

```cpp
float cosine_v3(const float* a, const float* b, size_t n) {
    __m512 sum_dot = _mm512_setzero_ps();
    __m512 sum_a2 = _mm512_setzero_ps();
    __m512 sum_b2 = _mm512_setzero_ps();

    for (size_t i = 0; i < n; i += 16) {
        __m512 va = _mm512_loadu_ps(a + i);
        __m512 vb = _mm512_loadu_ps(b + i);

        sum_dot = _mm512_fmadd_ps(va, vb, sum_dot);
        sum_a2 = _mm512_fmadd_ps(va, va, sum_a2);
        sum_b2 = _mm512_fmadd_ps(vb, vb, sum_b2);
    }

    float dot = _mm512_reduce_add_ps(sum_dot);
    float norm_a = _mm512_reduce_add_ps(sum_a2);
    float norm_b = _mm512_reduce_add_ps(sum_b2);

    return 1.0f - dot / (sqrtf(norm_a) * sqrtf(norm_b));
}
// æ€§èƒ½: 60 ns (16.7x faster!)
```

**æœ€ç»ˆæ€§èƒ½å¯¹æ¯” (768ç»´å‘é‡):**

| ç‰ˆæœ¬ | æ—¶é—´ | åŠ é€Ÿæ¯” | æŠ€æœ¯ |
|------|------|--------|------|
| v0 æ ‡é‡ | 1000ns | 1.0x | åŸºç¡€å¾ªç¯ |
| v1 å±•å¼€ | 400ns | 2.5x | 4è·¯å±•å¼€ |
| v2 AVX2 | 120ns | 8.3x | 8xfloat SIMD |
| v3 AVX-512 | 60ns | 16.7x | 16xfloat SIMD |

---

## 14. å­¦ä¹ èµ„æº

### 14.1 å¿…è¯»ä¹¦ç±

1. **ã€ŠComputer Architecture: A Quantitative Approachã€‹**
   - ä½œè€…: Hennessy & Patterson
   - ä¸»é¢˜: å¾®æ¶æ„ã€ç¼“å­˜ã€æµæ°´çº¿

2. **ã€ŠHacker's Delightã€‹**
   - ä½œè€…: Henry S. Warren Jr.
   - ä¸»é¢˜: ä½è¿ç®—æŠ€å·§

3. **ã€ŠSoftware Optimization for High-Performance Computingã€‹**
   - ä½œè€…: Intel
   - ä¸»é¢˜: SIMD, ç¼“å­˜ä¼˜åŒ–

### 14.2 åœ¨çº¿å·¥å…·

| å·¥å…· | ç”¨é€” | é“¾æ¥ |
|------|------|------|
| Compiler Explorer | æŸ¥çœ‹æ±‡ç¼–è¾“å‡º | godbolt.org |
| Quick Bench | åœ¨çº¿benchmark | quick-bench.com |
| uops.info | CPUæŒ‡ä»¤å»¶è¿Ÿ | uops.info |
| Intel Intrinsics Guide | SIMDå‚è€ƒ | software.intel.com |

### 14.3 å¼€æºé¡¹ç›®å­¦ä¹ 

ä¼˜ç§€çš„é«˜æ€§èƒ½C++é¡¹ç›®:
- **Folly** (Facebook): é«˜æ€§èƒ½åŸºç¡€åº“
- **Abseil** (Google): C++æ ‡å‡†åº“æ‰©å±•
- **FAISS** (Meta): å‘é‡æœç´¢
- **SimSIMD**: SIMDä¼˜åŒ–åº“
- **USearch**: æœ¬æ–‡æ¡£åŸºäºçš„é¡¹ç›®

---

## 15. æ€»ç»“Checklist

### æ€§èƒ½ä¼˜åŒ–æ£€æŸ¥æ¸…å•

**ç¼–è¯‘ä¼˜åŒ–:**
- [ ] ä½¿ç”¨ `-O3` æˆ– `-O2`
- [ ] å¯ç”¨ `-march=native`
- [ ] Releaseæ„å»ºå®šä¹‰ `-DNDEBUG`
- [ ] å…³é”®å‡½æ•°ä½¿ç”¨ `noexcept`
- [ ] è€ƒè™‘PGO (Profile-Guided Optimization)

**ç®—æ³•å±‚é¢:**
- [ ] é€‰æ‹©æ­£ç¡®çš„å¤§Oå¤æ‚åº¦ç®—æ³•
- [ ] å‡å°‘ä¸å¿…è¦çš„è®¡ç®—
- [ ] ç¼“å­˜é‡å¤è®¡ç®—ç»“æœ
- [ ] æ‰¹é‡å¤„ç†æ•°æ®

**å†…å­˜ä¼˜åŒ–:**
- [ ] é¢„åˆ†é…å†…å­˜,é¿å…çƒ­è·¯å¾„åˆ†é…
- [ ] å¯¹é½å…³é”®æ•°æ®ç»“æ„ (64å­—èŠ‚)
- [ ] ä½¿ç”¨å¯¹è±¡æ± /å†…å­˜æ± 
- [ ] è€ƒè™‘SoA vs AoSå¸ƒå±€
- [ ] å‹ç¼©æ•°æ®ç»“æ„

**ç¼“å­˜ä¼˜åŒ–:**
- [ ] æé«˜æ•°æ®å±€éƒ¨æ€§
- [ ] ä½¿ç”¨é¢„å–æŒ‡ä»¤
- [ ] é¿å…ä¼ªå…±äº«
- [ ] ä¿æŒå·¥ä½œé›† < L1ç¼“å­˜

**SIMDä¼˜åŒ–:**
- [ ] ä½¿ç”¨ç¼–è¯‘å™¨è‡ªåŠ¨å‘é‡åŒ–
- [ ] å¾ªç¯æ·»åŠ å‘é‡åŒ–æç¤º
- [ ] å¯¹é½æ•°æ®åˆ°16/32/64å­—èŠ‚
- [ ] è€ƒè™‘æ‰‹å†™intrinsics

**åˆ†æ”¯ä¼˜åŒ–:**
- [ ] ä½¿ç”¨æ¡ä»¶ç§»åŠ¨æ›¿ä»£åˆ†æ”¯
- [ ] æŸ¥è¡¨æ³•æ›¿ä»£å¤æ‚åˆ¤æ–­
- [ ] æé«˜åˆ†æ”¯å¯é¢„æµ‹æ€§
- [ ] å†·åˆ†æ”¯ç§»å‡ºçƒ­è·¯å¾„

**å¾®æ¶æ„ä¼˜åŒ–:**
- [ ] æ‰“ç ´é•¿ä¾èµ–é“¾
- [ ] å¤šè·¯ç´¯åŠ æé«˜ILP
- [ ] é¿å…Store-to-Loadè½¬å‘å¤±è´¥
- [ ] å‡å°‘ä¸å¿…è¦çš„å†…å­˜å±éšœ

**æµ‹é‡éªŒè¯:**
- [ ] Profileæ‰¾å‡ºçœŸæ­£ç“¶é¢ˆ
- [ ] BenchmarkéªŒè¯ä¼˜åŒ–æ•ˆæœ
- [ ] æ£€æŸ¥ç¼“å­˜æœªå‘½ä¸­ç‡
- [ ] ç›‘æ§åˆ†æ”¯é¢„æµ‹å¤±è´¥ç‡

---

**è®°ä½:** æ€§èƒ½ä¼˜åŒ–æ˜¯ä¸€ä¸ªè¿­ä»£è¿‡ç¨‹ã€‚æµ‹é‡ã€ä¼˜åŒ–ã€éªŒè¯ã€é‡å¤! ğŸš€

